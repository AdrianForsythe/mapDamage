#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import random
import sys
import os

"""
Copyright (c) 2012  Aurélien Ginolhac, Mikkel Schubert, Hákon Jónsson and Ludovic Orlando

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.
"""

"""
plot and quantify damage patterns from a SAM/BAM file

:Authors: Aurélien Ginolhac, Mikkel Schubert, Hákon Jónsson, Ludovic Orlando
:Contact: aginolhac@snm.ku.dk, MSchubert@snm.ku.dk, jonsson.hakon@gmail.com
:Date: November 2012
:Type: tool
:Input: SAM/BAM
:Output: tabulated tables, pdf

"""

# check if pysam if available
module = "pysam"
url = "http://code.google.com/p/pysam/"
try:
    __import__(module)
except ImportError, e:
    sys.stderr.write("Error: Could not import required module '%s':\n\t- %s\n" % (module,e))
    sys.stderr.write("       If module is not installed, please download from '%s'.\n" % (url,))
    sys.stderr.write("       A local install may be performed using the following command:\n")
    sys.stderr.write("       $ python setup.py install --user\n\n")
    sys.exit(1)

import pysam
import mapdamage


def downsample_reads(bamfile, downsample_to):
    if downsample_to is None:
        return bamfile
    elif downsample_to < 1:
        assert downsample_to > 0, "Downsample fraction must be positive, not %s" % downsample_to
        return (record for record in bamfile if random.random() < downsample_to)
    else:
        sample = [None] * downsample_to
        for (index, record) in enumerate(bamfile):
            if index >= downsample_to:
                index = random.randint(0, index)
                if index >= downsample_to:
                    continue
            sample[index] = record

        return filter(None, sample)


def main(argv):
    options = mapdamage.parseoptions.options(argv)
    if not options:
        return 1

    # plot using R if results folder already done
    if options.plot_only:
        if options.no_r:
            sys.stderr.write("Cannot use plot damage patterns if R is missing, terminating the program\n")
            return 1
        else:
            mapdamage.rscript.plot(options)
            return 0

    # Run the Bayesian estimation if the matrix construction is done
    if options.stats_only:
        # does not work for very low damage levels
        if mapdamage.tables.dmgFreqIsLow(options.folder):
            options.no_stats = True

        if options.no_stats:
            sys.stderr.write("Cannot use the Bayesian estimation, terminating the program\n")
            return 1
        else:
            mapdamage.rscript.runStats(options)
            return 0

    # open SAM/BAM file
    if options.filename == "-":
        in_bam = pysam.Samfile("-", 'rb')
    else:
        in_bam = pysam.Samfile(options.filename)

    # fetch all references and associated lengths in nucleotides
    try:
        ref = pysam.Fastafile(options.ref)
    except IOError:
        # Couldn't open the reference file
        sys.stderr.write("Couldn't open the reference file "+options.ref+" or there are permission problems writing the "+options.ref+".fai file\n")
        return 1

    reflengths = dict(zip(in_bam.references, in_bam.lengths))
    # check if references in SAM/BAM are the same in the fasta reference file
    fai_lengths = mapdamage.seq.read_fasta_index(options.ref + ".fai")
    if not fai_lengths:
        return 1
    elif (fai_lengths != reflengths):
        sys.stderr.write("Sequence dictionary in FASTA/BAM differs:\n")
        mapdamage.seq.describe_sequence_dicts(fai_lengths, reflengths)
        return 1

    # for misincorporation patterns, record mismaches
    misincorp = mapdamage.tables.initializeMut(reflengths, options.length)
    # for fragmentation patterns, record base compositions
    dnacomp =  mapdamage.tables.initializeComp(reflengths, options.around, options.length)
    # for length distributions
    lgdistrib =  mapdamage.tables.initializeLg()

    if not options.quiet:
        print("\tReading from '%s'" % options.filename)
        if  options.minqual != 0:
            print("\tFiltering out bases with a Phred score < %d" % options.minqual)
        if options.verbose:
            print("\t%d references are assumed in SAM/BAM file, for a total of %d nucleotides" % (len(reflengths), sum(reflengths.values())))
        print("\tWriting results to '%s/'" % options.folder)


    # open file handler to write alignements in fasta format
    if options.fasta:
        # use name of the sam/bam filename without extension
        ffasta = os.path.splitext(os.path.basename(options.filename))[0]+'.fasta'
        if not options.quiet:
            print("\tWriting alignments in '%s'" % ffasta)
        ff = open(options.folder+"/"+ffasta,"w")

    counter = filtered = 0

    # main loop
    for read in downsample_reads(in_bam, options.downsample):
        counter += 1

        if read.is_unmapped:
            filtered +=1
            continue

        # external coordinates 5' and 3' , 0-based offset
        coordinate = mapdamage.align.getCoordinates(read)
        # record aligned length for single-end reads
        lgdistrib = mapdamage.seq.recordLg(read, coordinate, lgdistrib)
        # fetch reference name, chromosome or contig names
        chrom = in_bam.getrname(read.tid)

        (before, after) = mapdamage.align.getAround(coordinate, chrom, reflengths, options.around, ref)
        refseq = ref.fetch(chrom, min(coordinate), max(coordinate)).upper()
        # read.query contains aligned sequences while read.seq is the read itself
        seq = read.query

        # add gaps according to the cigar string, do it for qualities if filtering options is on
        if options.minqual == 0:
            (seq, refseq) =  mapdamage.align.align(read.cigar, seq, refseq)
        else:
            (seq, qual, refseq) =  mapdamage.align.alignWithQual(read.cigar, seq, read.qqual, refseq)

        # reverse complement read and reference when mapped reverse strand
        if read.is_reverse:
            refseq = mapdamage.seq.revcomp(refseq)
            seq =  mapdamage.seq.revcomp(seq)
            beforerev =  mapdamage.seq.revcomp(after)
            after =  mapdamage.seq.revcomp(before)
            before = beforerev
            if options.minqual != 0:
                qual = mapdamage.seq.revcomp(qual)

        # record soft clipping when present
        mapdamage.align.recordSoftClipping(read, misincorp[chrom], options.length)

        if options.minqual == 0:
            # count misincorparations by comparing read and reference base by base
            mapdamage.align.getMis(read, seq, refseq, chrom, options.length, misincorp, '5p')
            # do the same with sequences align to 3'-ends
            mapdamage.align.getMis(read, seq[::-1], refseq[::-1], chrom, options.length, misincorp, '3p')
        else:
            # count misincorparations by comparing read and reference base by base, with quality filtering
            mapdamage.align.getMisWithQual(read, seq, qual, options.minqual, refseq, chrom, options.length, misincorp, '5p')
            # do the same with sequences align to 3'-ends
            mapdamage.align.getMisWithQual(read, seq[::-1], qual[::-1], options.minqual, refseq[::-1], chrom, options.length, misincorp, '3p')

        # count misincorparations by comparing read and reference base by base
        mapdamage.align.getMis(read, seq, refseq, chrom, options.length, misincorp, '5p')
        # do the same with sequences align to 3'-ends
        mapdamage.align.getMis(read, seq[::-1], refseq[::-1], chrom, options.length, misincorp, '3p')

        # compute base composition for genomic regions
        mapdamage.composition.countRefComp(read, chrom, before, after, dnacomp)
        # compute base composition for reads
        mapdamage.composition.countReadComp(read, chrom, options.length, dnacomp)

        if options.fasta:
            mapdamage.seq.writeFasta(read, chrom, seq, refseq, min(coordinate), max(coordinate), before, after, ff)

        if options.verbose:
            if counter % 50000 == 0:
                print("\t%10d reads processed (%d unmapped)" % (counter, filtered))

    if not options.quiet:
        print("\tDone. %d reads read (%d unmapped)" % (counter, filtered))

    # close file handlers
    in_bam.close()
    ref.close()
    if options.fasta:
        ff.close()

    # output results, write summary tables to disk
    with open(options.folder+"/"+"misincorporation.txt", 'w') as fmut:
        mapdamage.tables.printMut(misincorp, options, fmut)
    with open(options.folder+"/"+"dnacomp.txt", 'w') as fcomp:
        mapdamage.tables.printComp(dnacomp, options, fcomp)
    with open(options.folder+"/"+"lgdistribution.txt", 'w') as flg:
        mapdamage.tables.printLg(lgdistrib, options, flg)


    # plot using R
    if not options.no_r:
        mapdamage.rscript.plot(options)

    # does not work for very low damage levels
    if mapdamage.tables.dmgFreqIsLow(options.folder):
        options.no_stats = True

    # Run the Bayesian estimation
    if not options.no_stats:
        mapdamage.rscript.runStats(options)



    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
